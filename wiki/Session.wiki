#summary Describes the Session.
#labels Explained

*Contents*
<wiki:toc max_depth="3" />

= Introduction =

A `Session` represents the lifecycle of an Infinitum persistence service and acts as an interface to a configured application datastore. All database interaction should go through the `Session`, which also provides an API for creating [Criteria] instances.

`Session` instances should be acquired from an InfinitumContext. When a `Session` is acquired, it must be opened before any transactions take place. Subsequently, it should also be closed to close the persistence service and clean up any resources.

In order to keep track of transient and persistent entities, `Session` implements a `Session` cache. This cache can be configured to recycle automatically in order to reclaim memory in InfinitumCfgXml. The cache can also be explicitly recycled by invoking `recycleCache()` on the `Session`. Additionally, the cache size can be modified by calling `setCacheSize(int)`.

= Acquiring a `Session` =

The code below shows how a SQLite `Session` is acquired.

{{{
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    Session session = InfinitumContextFactory.getInstance().configure(this, R.xml.infinitum).getSession(this, DataSource.Sqlite);
    session.open(); // open for transactions
    // database transactions
    session.close(); // transactions may no longer be executed
}
}}}

= Runtime Configuration =

A `Session`'s configuration is pulled from an application's `InfinitumContext`; however, its configuration may also be modified at runtime. For example, autocommit may be enabled or the cache size may be altered.

{{{
session.setAutocommit(true);
session.setCacheSize(500);
}}}

= Autocommit- and Transaction- based Sessions =

An Infinitum `Session` can be configured to be in one of two modes: autocommit or transactional. In either case, `open()` must be invoked before database operations are made and `close()` invoked when a `Session` should be released. The difference between the two lies in how transactions are committed. With autocommit, transactions are committed implicitly as soon as they are executed. A transactional `Session` relies on transactions to handle commits explicitly, meaning a transaction must be opened within a `Session` and then explicitly committed. This method also allows for transactions to be rolled back. An example of both strategies is given below. Note that autocommit can be enabled or disabled in `infinitum.cfg.xml`, but is explicitly set in the examples to better illustrate what's going on.

== Autocommit Example ==

{{{
session.setAutocommit(true);
session.open();
session.save(new Foo()); // Foo is persisted
session.close();
}}}

== Transactional Example ==

{{{
session.setAutocommit(false);
session.open();
session.beginTransaction();
session.save(new Foo());
session.commit(); // Foo is persisted
session.close();
}}}

To rollback a transaction, `rollback()` is invoked:

{{{
session.setAutocommit(false);
session.open();
session.beginTransaction();
session.save(new Foo());
session.rollback(); // Foo is NOT persisted
session.close();
}}}

Transactions can be nested. When the outer transaction is ended all of the work done in that transaction and all of the nested transactions will be committed or rolled back.

= Basic CRUD Operations =

`Session` provides methods to easily save, update, or delete domain objects or collections of domain objects, making database persistence transparent. These methods are exemplified below.

== Persisting Domain Objects ==

{{{
// Save a single domain object
session.open();
session.save(new Foo());
session.close();

// Save a collection of domain objects
List<Foo> foos = getFooList();
session.open();
session.saveAll(foos);
session.close();
}}}

== Updating Domain Objects ==

{{{
// Update a single domain object
Foo foo = getFoo();
session.open();
session.update(foo);
session.close();

// Save or update a single domain object
Foo foo = getFoo();
session.open();
session.saveOrUpdate(foo);
session.close();

// Save or update a collection of domain objects
List<Foo> foos = getFooList();
session.open();
session.saveOrUpdateAll(foos);
session.close();
}}}

== Deleting Domain Objects ==

{{{
// Delete a single domain object
Foo foo = getFoo();
session.open();
session.delete(foo);
session.close();

// Delete a collection of domain objects
List<Foo> foos = getFooList();
session.open();
session.deleteAll(foos);
session.close();
}}}

== Loading Domain Objects ==

{{{
// Load a single domain object by its ID
session.open();
Foo foo = session.load(Foo.class, 42L);
session.close();
}}}

The `Criteria` API can be used to execute more advanced queries.

= Criteria Queries =

Further supporting the notion of persistence transparency, `Session` provides access to a [Criteria] API which is used to construct object-oriented database queries, removing the need for SQL. `Criteria` queries are used to query for a particular persistent class, and they allow for compile-time type checking, which means no casting is necessary. The code below details how to create a `Criteria` and execute a simple query for a domain object `Foo` by one of its fields `mId`.

== Criteria Query Example ==

{{{
session.open();
Foo foo = session.createCriteria(Foo.class).add(Conditions.eq("mId", 42)).unique();
session.close();
}}}

= Registering `TypeAdapters` =

In order to provide ORM support for unknown data types, Infinitum uses what's called a TypeAdapter. A `TypeAdapter` can be registered with a `Session` for a certain class, allowing fields of that class to be mapped to a database table.  Registering a `TypeAdapter` for a class which already has a `TypeAdapter` registered for it will result in the previous `TypeAdapter` being overridden. The example below, although slightly contrived, shows how a [http://joda-time.sourceforge.net/ JodaTime] `DateTime` object might be mapped to a SQLite column and vice versa using a `TypeAdapter`.

== `TypeAdapter` Example ==

{{{
// Store DateTimes as strings
session.registerTypeAdapter(DateTime.class, new SqliteTypeAdapter<DateTime>(SqliteDataType.TEXT) {
    @Override
    public void mapToObject(ResultSet result, int index, Field field, Object model) throws IllegalArgumentException, IllegalAccessException {
        field.set(model, result.getString(index));
    }
    @Override
    public void mapToColumn(DateTime value, String column, ContentValues values) {
	String dateStr = value.getYear() + "-" + value.getMonthOfYear() + "-" + value.getDayOfWeek();
	values.put(column, dateStr);
    }
    @Override
    public void mapObjectToColumn(Object value, String column, ContentValues values) {
        DateTime dt = (DateTime) value;
	String dateStr = dt.getYear() + "-" + dt.getMonthOfYear() + "-" + dt.getDayOfWeek();
	values.put(column, dateStr);
    }
});
}}}